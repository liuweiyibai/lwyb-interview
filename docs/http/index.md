# http 面试题

1. 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？

   请求头中 Connection 属性决定了连接是否持久。
   HTTP/1.0 中 Connection 默认是 close 的，即每次请求都会重新建立和断开 TCP 连接；
   HTTP/1.1 中 Connection 默认是 keep-alive 的，即 TCP 连接可以复用，不用每次都要重新建立和断开 TCP 连接。
   一般情况下复用的 TCP 连接在等待设置的超时时间之后还没有被任何连接使用的话，TCP 连接就会主动断开。

   所以答案是: 默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。

2. 一个 TCP 连接可以对应几个 HTTP 请求？
   一个 TCP 连接是可以发送多个 HTTP 请求的

3. 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？

   在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。所以一个大资源会阻塞后面的资源加载。队头阻塞
   在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。

4. 为什么有的时候刷新页面不需要重新建立 SSL 连接？
   TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。

5. 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？
   有，Chrome 最多允许对同一个 Host 建立六个 TCP 连接，不同的浏览器有一些区别。

6. 若收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？

   1. 如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。

   2. 如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，若所有的连接都正在发送请求，那么其他的请求就只能等待。

7. 从输入 url 都页面展现出来都发生了什么

   浏览器会构建请求行，构建请求行之后开始检查缓存。检查强缓存（本地缓存），如果命中就直接使用，否则就进行 dns 解析，dns 解析(包括本机 dns 和浏览器 dns 缓存)，远程 dns 服务器解析（递归解析，dns 和服务器缓存），建立 tcp 链接(三次握手)，浏览器向 web 服务器发送 http 请求，服务器返回 http 报文，浏览器解析页面，链接断开（四次挥手），http 请求结束。

8. 三次握手和四次挥手

   三次握手就是在建立 tcp 链接是一个发送包的过程，就是保证建立一个可靠的链接。
   通过三次握手（即总共发送三个数据包来确认已经建立连接），客户端和服务端之间互相确认，都具备收发能力，建立客户端和服务端之间的连接

   1. 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

   2. 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

   3. 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

   四次挥手就是 tcp 链接在断开始一个确认断开的过程，

9. 缓存相关，强缓存，协商缓存

   强缓存是 利用 Expires 和 Cache-Control 两个字段来控制，用来表示资源的缓存时间，强缓存命中，普通刷新会忽略，但不会清除，强制刷新会清除。浏览器强制刷新，请求会带上 Cache-Control:no-cache 或者 Pragma:no-cache。

   那么什么是 Expires 和 Cache-Control 呢？它们分别是 1.0 和 1.1 出现的用来表示缓存的过期时间的。其中 Cache-Control 优先级高。 Cache-Control 的可选值

   1. no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。
   2. no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
   3. public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。
   4. private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。
   5. max-age=300

10. HTTP 请求响应常见状态码

    1. 100~199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。
    2. 200~299：表示成功接收请求并已完成整个处理过程。常用 200。
    3. 300~399：为完成请求，客户需进一步细化请求。例如：请求的资源已经移动一个新地址、常用 302（意味着你请求我，我让你去找别人）, 307 和 304（我不给你这个资源，自己拿缓存）
    4. 400~499：客户端的请求有错误，常用 404（意味着你请求的资源在 web 服务器中没有）403（服务器拒绝访问，权限不够）
    5. 500~599：服务器端出现错误，常用 500

11. http 与 https 的区别
12. http 握手的次数以及过程
13. http2 有哪些新特性？http2 还有哪些缺陷？http3 的一些了解？
14. https 加密原理？主要是讲对称加密和非对此加密结合使用的一个过程。

    非对称加密获取公钥，然后根据公钥对称加密通信

15. 什么是中间人攻击？和 http 区别？
16. 前端安全防范措施？xss 攻击和 csrf 攻击？
17. http 的几种请求方法和区别

    options 预请求
    get put post delete 增删改查
    参数，url参数 body 参数
    请求可以被缓存，所以get请求常用来做查询

## axios 相关

1. 说一下 axios 的工作流程

   axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范，它本身具有以下特征：

   1. 从浏览器中创建 XMLHttpRequest

   2. 支持 Promise API

   3. 客户端支持防止 CSRF

   4. 提供了一些并发请求的接口（重要，方便了很多的操作）

   5. 拦截请求和响应

   6. 转换请求和响应数据

   7. 取消请求

   8. 自动转换 JSON 数据

   防止 CSRF: 就是让你的每个请求都带一个从 cookie 中拿到的 key, 根据浏览器同源策略，假冒的网站是拿不到你 cookie 中得 key 的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。
