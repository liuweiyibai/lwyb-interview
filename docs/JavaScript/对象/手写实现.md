# 手写

## 继承

## new 关键字

```js
/**
 * new1(ctor,...otherArgs)
 * @param {*} ctor 构造函数
 * @returns 返回实例
 */
function new1(ctor) {
  if (typeof ctor !== 'function') {
    return;
  }
  // 可以用来判断某个函数是不是被 new 调用
  new1.target = ctor;
  var newObjectPrototype = Object.create(ctor.prototype);
  var newResult = ctor.apply(
    newObjectPrototype,
    Array.prototype.slice.call(arugments, 1)
  );
  // new 的定义，如果构造函数返回了非 null 对象或者函数，那么久直接返回，否则返回

  var isObject = typeof newResult === 'object' && newResult !== null;
  var isFunction = typeof newResult === 'function';

  if (isObject || isFunction) {
    return newResult;
  }
  // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。
  return newObjectPrototype;
}
```

## create 函数

首先看一下该方法的作用：`Object.create()` 方法创建一个新的对象，并以方法的第一个参数作为新对象的`__proto__`属性的值（以第一个参数作为新对象的构造函数的原型对象）

`Object.create()` 方法还有第二个可选参数，是一个对象，对象的每个属性都会作为新对象的自身属性，对象的属性值以 descriptor（Object.getOwnPropertyDescriptor(obj, 'key')）的形式出现，且 enumerable 默认为 false

```js
function create(proto, des) {
  function Fn() {}
  Fn.prototype = proto;
  var ins = new Fn();
  if (des) {
    Object.definePropertis(ins, des);
  }
  return ins;
}
```

## instanceof 实现

instanceof 是用来判断实例是否是类的实例，所以可以实现:

```js
function instance(target, origin) {
  while (true) {
    if (target.__proto__ === null) return false;
    if (target.__proto__ === origin.prototype) {
      return true;
    }
    // 继续向上查找
    target = target.__proto__;
  }
}
```
