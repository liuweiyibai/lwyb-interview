# 生成器

generator 生成器可以生成 '迭代器'，它是一个函数，和普通函数不一样，可以有暂停的功能，可以暂停函数执行

我们通过一段函数来模拟一下生成器的执行过程，迭代器就是有 next 方法的，没次调用后都会返回一个 done 和一个叫 value 的属性

```js
function read(arrs) {
  let index = 0; //默认先迭代第一项
  let len = arrs.length;
  return {
    next() {
      return { value: arrs[index], done: index++ === len ? true : false };
    },
  };
}
let it = read(['react', 'vue', 'angular']);
let flag = true;
// 通过 循环调用
do {
  let { done, value } = it.next();
  flag = done;
  console.log(value);
} while (!flag);
// 或者一步一步的调用
// it.next(); // {done:false,value:'react'}
// it.next(); // {done:false,value:'vue'}
// it.next(); // {done:false,value:'angular'}
// it.next(); // {done:true,value:undefined}
```

生成器函数使用 \* 定义， 生成器函数和普通函数长的不一样，返回迭代器，yield(暂停 产出)。
它会将函数分割出好多个部分，调用一次 next 就会继续向下执行，返回结果是一个迭代器 迭代器有一个 next 方法，yield 后面跟着的是 value 的值，yield 等号前面的是我们当前调用 next 传进来的值，第一次 next 传值是无效的

```js
function* read(arrs) {
  //genrator函数可以配yield 产出
  yield arrs[0];
  yield arrs[1];
  yield arrs[2];
}
let it = read(['react', 'vue', 'angular']);
do {
  let { done, value } = it.next();
  flag = done;
  console.log(value);
} while (!flag);
```

co 库可以自动的将 generator 进行迭代

```js
function* r() {
  let content1 = yield read('./2.promise/1.txt', 'utf8');
  let content2 = yield read(content1, 'utf8');
  return content2;
}
// co库 npm install co 可以自动的将generator进行迭代
// let co = require('co');
// co 的简单实现
function co(it) {
  return new Promise(function (resolve, reject) {
    function next(d) {
      let { value, done } = it.next(d);
      if (!done) {
        value.then(function (data) {
          // 2,txt
          next(data);
        }, reject);
      } else {
        resolve(value);
      }
    }
    next();
  });
}
co(r()).then(function (data) {
  console.log(data);
});
```
