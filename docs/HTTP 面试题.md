# HTTP 面试题

1. 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？

   请求头中 Connection 属性决定了连接是否持久。
   HTTP/1.0 中 Connection 默认是 close 的，即每次请求都会重新建立和断开 TCP 连接；
   HTTP/1.1 中 Connection 默认是 keep-alive 的，即 TCP 连接可以复用，不用每次都要重新建立和断开 TCP 连接。
   一般情况下复用的 TCP 连接在等待设置的超时时间之后还没有被任何连接使用的话，TCP 连接就会主动断开。

   所以答案是: 默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。

2. 一个 TCP 连接可以对应几个 HTTP 请求？
   一个 TCP 连接是可以发送多个 HTTP 请求的，具体和浏览器限制有关系。

3. 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？

   有，Chrome 最多允许对同一个 Host 建立六个 TCP 连接，不同的浏览器有一些区别。

4. 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？

   在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。所以一个大资源会阻塞后面的资源加载。队头阻塞
   在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。

5. 为什么有的时候刷新页面不需要重新建立 SSL 连接？
   TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。

6. 若收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？

   1. 如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。

   2. 如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，若所有的连接都正在发送请求，那么其他的请求就只能等待。

7. 从输入 url 都页面展现出来都发生了什么

   1. 浏览器会构建请求行，构建请求行之后开始检查缓存。检查强缓存（本地缓存），如果命中就直接使用
   2. 否则就进行 dns 解析，dns 解析(包括本机 dns 和浏览器 dns 缓存)，远程 dns 服务器解析（递归解析，dns 和服务器缓存）dns->ip
   3. 建立 tcp 链接(三次握手)，浏览器向 web 服务器发送 HTTP 请求，服务器返回 HTTP 报文内容
   4. 浏览器解析页面，链接断开（四次挥手），HTTP 请求结束。
   5. 解析 html 生成 dom 树，解析 css 生成 cssom 树，结合两棵树生成渲染树，根据渲染树计算每个节点信息，根据节点信息渲染页面。

   最全的答案:

   1. 用户输入 url 并回车
   2. 浏览器进程检查 url，组装协议，构成完整的 url
   3. 浏览器进程通过进程间通信（IPC）把 url 转发给网络进程
   4. 网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
   5. 如果没有，网络进程向 web 服务器发起 HTTP 请求（网络请求），请求流程如下：
      1. 进行 DNS 解析，获取服务器 ip 地址、端口
      2. 利用 ip 地址和服务器建立 tcp 连接
      3. 构建请求头信息
      4. 发送请求头信息
      5. 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
   6. 网络进程解析响应流程；
      1. 检查状态码，如果是 301/302，则需要重定向，从 Location 自动中读取地址，重新进行上一步；如果是 200，则继续处理请求。
      2. 200 响应处理：
         检查响应类型 Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行；如果是 html 则通知浏览器进程准备渲染进程准备进行渲染。
   7. 准备渲染进程
      1. 浏览器进程检查当前 url 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程。
   8. 传输数据、更新状态
      1. 渲染进程准备好后，浏览器向渲染进程发起「提交文档」的消息，渲染进程接收到消息和网络进程建立传输数据的「管道」；
      2. 渲染进程接收完数据后，向浏览器发送「确认提交」；
      3. 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏 url、前进后退的历史状态、更新 web 页面，此时的 web 页面是空白页。
   9. 渲染进程对文档进行页面解析和子资源加载，生成最终页面
      1. HTML：根据 HTML 解析出 DOM 树；
      2. CSS：根据 CSS 解析生成 CSS 规则树；
      3. 结合 DOM 树和 CSS 规则树，生成渲染树；根据渲染树计算每一个节点的信息，最后根据计算好的信息绘制页面。

8. HTTP 握手的次数以及过程

   三次握手和四次挥手

   三次握手就是在建立 tcp 链接是一个发送包的过程，就是保证建立一个可靠的链接。
   通过三次握手（即总共发送三个数据包来确认已经建立连接），客户端和服务端之间互相确认，都具备收发能力，建立客户端和服务端之间的连接

   1. 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

   2. 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

   3. 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

   四次挥手就是 tcp 链接在断开始一个确认断开的过程，

9. 缓存相关，强缓存，协商缓存

   强缓存是 利用 Expires 和 Cache-Control 两个字段来控制，用来表示资源的缓存时间，强缓存命中，普通刷新会忽略，但不会清除，强制刷新会清除。浏览器强制刷新，请求会带上 Cache-Control:no-cache 或者 Pragma:no-cache。

   那么什么是 Expires 和 Cache-Control 呢？它们分别是 1.0 和 1.1 出现的用来表示缓存的过期时间的。其中 Cache-Control 优先级高。 Cache-Control 的可选值

   1. no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。
   2. no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
   3. public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。
   4. private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。
   5. max-age=300

10. HTTP 请求响应常见状态码

    1. 100~199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。
    2. 200~299：表示成功接收请求并已完成整个处理过程。常用 200。
    3. 300~399：为完成请求，客户需进一步细化请求。例如：请求的资源已经移动一个新地址、常用 302（意味着你请求我，我让你去找别人）, 307 和 304（我不给你这个资源，自己拿缓存）
    4. 400~499：客户端的请求有错误，常用 404（意味着你请求的资源在 web 服务器中没有）403（服务器拒绝访问，权限不够）
    5. 500~599：服务器端出现错误，常用 500

11. HTTP 与 HTTPS 的区别
    多了一层 ssl 通信验证

12. HTTP2 有哪些新特性？HTTP2 还有哪些缺陷？HTTP3 的一些了解？

    1. 多路复用，不同于 HTTP1.1 的 keep-alive，客户端向某个域名的服务器请求页面的过程中，只会创建一条 TCP 连接，将文件内容分成多个 stream，所以文件可以并行加载.
    2. 头部压缩
    3. 服务端推送

13. HTTPS 加密原理？HTTPS 涉及的加密算法有哪些

    主要是讲对称加密和非对此加密结合使用的一个过程。HTTPS 保证的只是传输过程安全。非对称加密获取公钥，然后根据公钥对称加密通信。

14. 什么是中间人攻击？

    中间人攻击，浏览器发送请求被中间人拦截，中间人返回自己的 HTTPS 证书，客户端和中间人进行 HTTPS 通信。中间人再以客户端身份向服务器发送请求，拿到服务器的 HTTPS 公钥，然后同服务器进行通信，这样整个通信过程都会经过中间人，所以中间人可以拿到所有数据。

15. 如何防范中间人攻击？

16. 前端安全防范措施？xss 攻击和 csrf 攻击？

    XSS（跨站脚本攻击）是指攻击者在返回的 HTML 中嵌入 JavaScript 脚本，为了减轻这些攻击，需要在 HTTP 头部配上，set-cookie：

    1. httponly-这个属性可以防止 XSS,它会禁止 JavaScript 脚本来访问 cookie。
    2. secure - 这个属性告诉浏览器仅在请求为 https 的时候发送 cookie。

17. HTTP 的几种请求方法和区别

    options 预请求
    get put post delete 增删改查
    参数，url 参数 body 参数
    请求可以被缓存，所以 get 请求常用来做查询

18. get 请求传参有长度限制嘛？

    实际上 HTTP 协议并没有规定 GET/POST 请求长度的限制。对 GET 请求参数的限制是浏览器或者 Web 服务器，浏览器或 Web 服务器规定了 url 长度的限制，并且不同的浏览器 url 限制的 url 长度也不一样。

19. get 和 post 请求的区别?

    参数携带，POST 参数是在 body 传递，GET 参数是在 url 中传递。正是由于 GET 参数携带在 url 中，所以可以被浏览器缓存，类似于查找的过程。

20.

## axios 相关

1. 说一下 axios 的工作流程

   axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范，它本身具有以下特征：

   1. 从浏览器中创建 XMLHttpRequest

   2. 支持 Promise API

   3. 客户端支持防止 CSRF

   4. 提供了一些并发请求的接口（重要，方便了很多的操作）

   5. 拦截请求和响应

   6. 转换请求和响应数据

   7. 取消请求

   8. 自动转换 JSON 数据

   9. 防止 CSRF

      就是让你的每个请求都带一个从 cookie 中拿到的 key, 根据浏览器同源策略，假冒的网站是拿不到你 cookie 中得 key 的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。

2. 你对 axios 二次封装都做哪些事情

   防抖节流、失败重试、缓存能力、参数统一处理、拦截器的使用
