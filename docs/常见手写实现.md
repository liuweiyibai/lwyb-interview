# 手写实现

- 实现一个对象的 flatten 方法

  给出如下结构，将对象进行降维

  ```js
  const obj = {
    a: {
      b: 1,
      c: 2,
      d: { e: 5 },
    },
    b: [1, 3, { a: 2, b: 3 }],
    c: 3,
  };

  flatten(obj);
  // 结果返回如下:
  // {
  //  'a.b': 1,
  //  'a.c': 2,
  //  'a.d.e': 5,
  //  'b[0]': 1,
  //  'b[1]': 3,
  //  'b[2].a': 2,
  //  'b[2].b': 3
  //   c: 3
  // }
  ```

  ```js
  function isObject(val) {
    return typeof val === 'object' && typeof val !== null;
  }
  function flatten(obj) {
    if (!isObject(obj)) {
      return;
    }
    const resp = {};
    function deep(cur, prefix = '') {
      if (isObject(cur)) {
        if (Array.isArray(cur)) {
          cur.forEach((t, index) => {
            deep(t, `${prefix}[${index}]`);
          });
        } else {
          for (let key in cur) {
            deep(cur[key], `${prefix}${prefix ? '.' : ''}${key}`);
          }
        }
      } else {
        resp[prefix] = cur;
      }
    }

    deep(obj);
    return resp;
  }
  ```

- 判断括号字符串是否有效

  给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

  有效字符串需满足：

  左括号必须用相同类型的右括号闭合。
  左括号必须以正确的顺序闭合。

  示例 1：

  输入：s = "()"
  输出：true

  示例 2：

  输入：s = "()[]{}"
  输出：true

  示例 3：

  输入：s = "(]"
  输出：false

  ```js
  function isValid(str) {
    if (str.length % 2 === 1) {
      return false;
    }

    const regObj = {
      '{': '}',
      '(': ')',
      '[': ']',
    };

    const stack = [];

    for (let i = 0; i < str.length; i++) {}
  }
  ```

- 查找数组公共前缀

  编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""

  示例 1：

  输入：strs = ["flower","flow","flight"]
  输出："fl"

  示例 2：

  输入：strs = ["dog","racecar","car"]
  输出：""
  解释：输入不存在公共前缀。

  ```js
  function longestCommonPrefix(strs) {
    const str = strs[0];
    let index = 0;
    while (index < str.length) {
      const strCur = str.slice(0, index + 1);
      for (let i = 0; i < strs.length; i++) {
        // 空字符串 ||
        if (!strs[i] || !strs[i].startsWith(strCur)) {
          return str.slice(0, index);
        }
      }
      index++;
    }
    return str;
  }
  ```

- 如何找到数组中第一个没出现的最小正整数 怎么优化

  给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

  请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

  示例 1：

  输入：nums = [1,2,0]
  输出：3

  示例 2：

  输入：nums = [3,4,-1,1]
  输出：2

  示例 3：

  输入：nums = [7,8,9,11,12]
  输出：1

  ```js

  ```
